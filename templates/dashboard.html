<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitHub Webhook Dashboard | TechStaX</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
  <base target="_blank">
</head>
  <body>
    <div class="container">
      <header>
        <h1>ðŸš€ GitHub Webhook Events</h1>
        <p class="subtitle">Real-time repository activity monitor</p>
        <div class="status">
          <span class="status-indicator" id="status-indicator"></span>
          <span id="status-text">Connecting...</span>
          <span class="last-updated" id="last-updated"></span>
        </div>
      </header>

      <main>
        <div class="events-container" id="events-container">
          <div class="empty-state" id="empty-state">
            <p>Waiting for events...</p>
            <p class="hint">
              Trigger a push or pull request in your action-repo to see activity
              here.
            </p>
          </div>
          <ul class="events-list" id="events-list" style="display: none"></ul>
        </div>
      </main>

      <footer>
        <p>TechStaX Assignment | Auto-refresh every 15 seconds</p>
      </footer>
    </div>

    <script>
      // Configuration
      const POLL_INTERVAL = 15000; // 15 seconds
      const API_ENDPOINT = "/api/events";
      const MAX_RETRY = 5;
      const MAX_EVENTS = 50;

      // State
      let lastSeenTimestamp = null;
      let displayedEventIds = new Set();
      let pollTimer = null;
      let retryCount = 0;
      let isFirstLoad = true;

      // DOM Elements
      const eventsList = document.getElementById("events-list");
      const emptyState = document.getElementById("empty-state");
      const statusIndicator = document.getElementById("status-indicator");
      const statusText = document.getElementById("status-text");
      const lastUpdated = document.getElementById("last-updated");

      // Initialize
      document.addEventListener("DOMContentLoaded", () => {
        // Clear any existing UI on page load
        eventsList.innerHTML = "";
        displayedEventIds.clear();

        // Full sync on first load
        fetchEvents(true);
        startPolling();

        // Handle tab visibility changes
        document.addEventListener("visibilitychange", handleVisibilityChange);
      });

      function handleVisibilityChange() {
        if (document.hidden) {
          console.log("Tab hidden, pausing polling");
          stopPolling();
        } else {
          console.log("Tab visible, resuming with full sync");
          // Do full sync when tab becomes visible again
          fetchEvents(true);
          startPolling();
        }
      }

      function startPolling() {
        // Clear existing timer before starting new one
        stopPolling();
        pollTimer = setInterval(() => fetchEvents(false), POLL_INTERVAL);
      }

      function stopPolling() {
        if (pollTimer) {
          clearInterval(pollTimer);
          pollTimer = null;
        }
      }

      async function fetchEvents(fullSync = false) {
        try {
          updateStatus(fullSync ? "syncing" : "loading");

          let url = API_ENDPOINT;

          // Only use last_seen for polling, not for full sync
          if (!fullSync && lastSeenTimestamp) {
            url += `?last_seen=${encodeURIComponent(lastSeenTimestamp)}`;
          }

          const response = await fetch(url);

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();

          // Reset retry count on success
          retryCount = 0;

          if (data.events && data.events.length > 0) {
            // Update last seen timestamp to the most recent event
            const newestEvent = data.events[0];
            lastSeenTimestamp = newestEvent.timestamp;

            if (fullSync) {
              // Full sync: clear and rebuild everything
              eventsList.innerHTML = "";
              displayedEventIds.clear();
              renderEvents(data.events, false); // Append in order
              isFirstLoad = false;
            } else {
              // Normal polling: only add new events
              const newEvents = data.events.filter(
                (e) => !displayedEventIds.has(e.id)
              );
              if (newEvents.length > 0) {
                renderEvents(newEvents, true); // Prepend new events
              }
            }
          } else if (fullSync) {
            // No events on full sync - show empty state
            eventsList.innerHTML = "";
            displayedEventIds.clear();
            emptyState.style.display = "block";
            eventsList.style.display = "none";
          }

          // Update status with actual displayed count
          updateStatus("connected", displayedEventIds.size);
        } catch (error) {
          console.error("Fetch error:", error);
          handleFetchError(error, fullSync);
        }
      }

      function handleFetchError(error, fullSync) {
        const errorMessage =
          error.message || "Failed to connect to server. Retrying...";
        updateStatus("error", displayedEventIds.size, errorMessage);

        // Exponential backoff for retries
        if (retryCount < MAX_RETRY) {
          const delay = Math.min(1000 * Math.pow(2, retryCount), 30000);
          console.log(
            `Retrying in ${delay}ms (attempt ${retryCount + 1}/${MAX_RETRY})`
          );

          setTimeout(() => {
            retryCount++;
            fetchEvents(fullSync);
          }, delay);
        } else {
          updateStatus(
            "error",
            displayedEventIds.size,
            "Max retries reached. Please refresh the page."
          );
        }
      }

      function renderEvents(events, prepend = false) {
        // Hide empty state if we have events
        if (events.length > 0) {
          emptyState.style.display = "none";
          eventsList.style.display = "block";
        }

        events.forEach((event) => {
          // Skip if already displayed
          if (displayedEventIds.has(event.id)) {
            console.log("Skipping duplicate event:", event.id);
            return;
          }
          displayedEventIds.add(event.id);

          const li = document.createElement("li");
          li.className = `event-item event-${event.action.toLowerCase()}`;
          li.dataset.id = event.id;

          const icon = getEventIcon(event.action);

          li.innerHTML = `
            <div class="event-icon">${icon}</div>
            <div class="event-content">
              <p class="event-message">${escapeHtml(event.message)}</p>
              <div class="event-meta">
                <span class="event-type">${event.action}</span>
                <span class="event-time">${formatTime(event.timestamp)}</span>
                <span class="event-id">#${event.request_id}</span>
              </div>
            </div>
          `;

          if (prepend) {
            eventsList.insertBefore(li, eventsList.firstChild);
          } else {
            eventsList.appendChild(li);
          }

          // Animation for new items
          li.style.animation = "slideIn 0.3s ease-out";
        });

        // Limit displayed events to prevent DOM bloat
        while (eventsList.children.length > MAX_EVENTS) {
          const removed = eventsList.lastChild;
          if (removed && removed.dataset.id) {
            displayedEventIds.delete(removed.dataset.id);
          }
          eventsList.removeChild(removed);
        }
      }

      function getEventIcon(action) {
        const icons = {
          PUSH: "â¬†ï¸",
          PULL_REQUEST: "ðŸ”€",
          MERGE: "âœ…",
        };
        return icons[action] || "ðŸ“‹";
      }

      function updateStatus(status, count = 0, message = null) {
        statusIndicator.className = "status-indicator " + status;

        const now = new Date().toLocaleTimeString();

        switch (status) {
          case "connected":
            const countText = count === 1 ? "1 event" : `${count} events`;
            statusText.textContent = `Live â€¢ ${countText}`;
            lastUpdated.textContent = `Updated: ${now}`;
            break;
          case "syncing":
            statusText.textContent = message || "Syncing with server...";
            lastUpdated.textContent = `Updated: ${now}`;
            break;
          case "loading":
            statusText.textContent = message || "Updating...";
            break;
          case "error":
            statusText.textContent = message || "Connection error â€¢ Retrying...";
            lastUpdated.textContent = `Failed: ${now}`;
            break;
          default:
            statusText.textContent = "Connecting...";
        }
      }

      function formatTime(isoString) {
        try {
          const date = new Date(isoString);
          return date.toLocaleString();
        } catch {
          return isoString;
        }
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Cleanup on page unload
      window.addEventListener("beforeunload", () => {
        stopPolling();
        document.removeEventListener("visibilitychange", handleVisibilityChange);
      });
    </script>
  </body>
</html>